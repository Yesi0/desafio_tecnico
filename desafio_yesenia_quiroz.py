# -*- coding: utf-8 -*-
"""desafio_yesenia_quiroz.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fCCjA6Ux9sRFYEeK5VzznQUKTse2VELm
"""

import pandas as pd
import datetime as dt
import seaborn as sns
import numpy as np
from matplotlib import pyplot as plt
from matplotlib.ticker import FuncFormatter
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

"""# LIMPIEZA DE DATOS Y ANÁLISIS




"""

#Por el gran tamaño de los datos se hará una partición más pequeña  que podrá ser almacenado en memoria
# tamaño máximo de filas de cada partición
size = 100000

# Crear un objeto iterador 'df_chunk' que contendrá las particiones
#df_chunk = pd.read_csv('data_test_aa.csv', sep='|', chunksize=size)

# Crear una variable booleana 'header' para exportar las cabeceras solo en la primera iteración
header = True

# Ruta del archivo de resultado
#resultado_csv = 'resultado.csv'

# Iterar sobre cada partición y exportar al archivo CSV final
#for chunk in df_chunk:
    # Exportar el resultado al archivo CSV final
    #chunk.to_csv(resultado_csv, header=header, mode='a', index=False)

    # Después de la primera iteración, establecer 'header' como False para no agregar cabeceras adicionales
    #header = False

pd.read_csv('resultado.csv', sep = ',')

data = pd.read_csv('resultado.csv', sep = ',')
data

# Contar valores nulos por columna
nulos_por_columna = data.isnull().sum()

# Contar duplicados
duplicados_totales = data.duplicated().sum()


print("Número de valores nulos por columna:")
print(nulos_por_columna)

print("\nNúmero total de duplicados:", duplicados_totales)

# combinaciones únicas a verificar
combinaciones_unicas = [['cliente', 'pedido'],
                        ['pedido', 'fecha_pedido'],
                        ['cliente', 'fecha_atencion']]

# Verificar la unicidad de las combinaciones seleccionadas
for combinacion in combinaciones_unicas:
    duplicados = data.duplicated(subset=combinacion)
    num_duplicados = duplicados.sum()
    print(f"Número de duplicados en la combinación {combinacion}: {num_duplicados}")

cliente_atencion = data[['cliente', 'fecha_atencion']].drop_duplicates()
total_id = len(cliente_atencion)

cliente_atencion

# Copiamos el DataFrame para no modificar el original
cleaned_data = data.copy()

# Excluimos las variables 'fecha_atencion' y 'comuna'
cleaned_data = cleaned_data.drop(['fecha_atencion', 'comuna'], axis=1)

# Cambiamos el formato de 'fecha_pedido' a solo fecha
#cleaned_data['fecha_pedido'] = cleaned_data['fecha_pedido'].dt.date

print(cleaned_data.info())

cleaned_data['ingresos_netos'] = cleaned_data['valor'] + cleaned_data['descuento']
cleaned_data

# Convertir la columna 'fecha_pedido' a datetime
cleaned_data['fecha_pedido'] = pd.to_datetime(cleaned_data['fecha_pedido'])

# Mostrar los tipos de datos de las variables
tipos_de_datos = cleaned_data.dtypes
print(tipos_de_datos)

"""#1. ESTADO DE VENTAS

"""

# Filtrar los datos para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]

# Agrupar por fecha y calcular los ingresos netos diarios para los últimos 3 meses
ingresos_diarios = ultimos_3_meses.groupby(ultimos_3_meses['fecha_pedido'].dt.date)['ingresos_netos'].sum()

cleaned_data['fecha_pedido'] = pd.to_datetime(cleaned_data['fecha_pedido'])

# Calcular el total por mes
total_por_mes = cleaned_data.groupby(cleaned_data['fecha_pedido'].dt.to_period('M'))['total'].sum()

print(total_por_mes)

# Filtrar los datos para los últimos 3 meses excepto noviembre
ultimos_3_meses = cleaned_data[(cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=3)) & (cleaned_data['fecha_pedido'].dt.month != 11)]


# Agrupar por fecha y calcular los ingresos netos mensuales para los últimos 3 meses excepto noviembre
ingresos_mensuales = ultimos_3_meses.groupby(ultimos_3_meses['fecha_pedido'].dt.to_period('M'))['total'].sum()

# Crear el gráfico de barras principal
fig, ax = plt.subplots(figsize=(14, 12))
barplot = ax.bar(total_por_mes.index.astype(str), total_por_mes.values, color='skyblue')
ax.set_title('Total de Ventas Histórico')
ax.set_xlabel('Fecha')
ax.set_ylabel('Total de Ventas (en millones)')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))
ax.tick_params(axis='x', rotation=45)

# Desactivar las líneas de fondo del gráfico principal
ax.xaxis.grid(False)
ax.yaxis.grid(False)

# Crear un eje secundario para el gráfico más pequeño (últimos 3 meses) dentro del gráfico principal
ax2 = ax.inset_axes([0.75, 0.82, 0.2, 0.15])

# Desactivar las líneas de fondo del gráfico secundario
ax2.xaxis.grid(False)
ax2.yaxis.grid(False)

# Segundo gráfico - línea para los últimos 3 meses excepto noviembre
lineplot = sns.lineplot(x=ingresos_mensuales.index.astype(str), y=ingresos_mensuales.values, color='blue', marker='o', ax=ax2)
ax2.set_title('Últimos 3 Meses')
ax2.set_xlabel('Fecha (Mes)')
ax2.set_ylabel('Ingresos Netos Mensuales')

# Ajustar la escala del eje y del segundo gráfico para reflejar los valores reales
#ax2.set_ylim(bottom=0, top=ingresos_mensuales.max() + 5000000)

# Formatear el eje Y del segundo gráfico en millones
ax2.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))

# Ajustar la ubicación del gráfico secundario
ax2.set_xticks(range(len(ingresos_mensuales.index)))
ax2.set_xticklabels(ingresos_mensuales.index.astype(str), rotation=45, ha='right')

# Agregar etiquetas para cada barra en el gráfico principal
for rect in barplot:
  height = rect.get_height()
  ax.annotate(f'{height/1e6:.0f}M', xy=(rect.get_x() + rect.get_width() / 2, height), xytext=(0, 3), # 3 points vertical offset
  textcoords="offset points", ha='center', va='bottom')

plt.tight_layout()
plt.show()

cleaned_data['fecha_pedido'] = pd.to_datetime(cleaned_data['fecha_pedido'])

# Calcular ingresos netos por mes
ingresos = cleaned_data.groupby(cleaned_data['fecha_pedido'].dt.to_period('M'))['ingresos_netos'].sum()

print(ingresos)

# Filtrar los datos para los últimos 3 meses excepto noviembre
ultimos_3_meses = cleaned_data[(cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=3)) & (cleaned_data['fecha_pedido'].dt.month != 11)]


# Agrupar por fecha y calcular los ingresos netos mensuales para los últimos 3 meses excepto noviembre
ingresos_mensuales = ultimos_3_meses.groupby(ultimos_3_meses['fecha_pedido'].dt.to_period('M'))['ingresos_netos'].sum()



# Configurar el estilo del fondo sin líneas
sns.set_style("whitegrid")

# Crear el gráfico de barras principal
fig, ax = plt.subplots(figsize=(14, 12))
barplot = ax.bar(ingresos.index.astype(str), ingresos.values, color='skyblue')
ax.set_title('Total de Ingresos Histórico')
ax.set_xlabel('Fecha')
ax.set_ylabel('Total de ingresos (en millones)')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))
ax.tick_params(axis='x', rotation=45)

# Desactivar las líneas de fondo del gráfico principal
ax.xaxis.grid(False)
ax.yaxis.grid(False)

# Crear un eje secundario para el gráfico más pequeño (últimos 3 meses) dentro del gráfico principal
ax2 = ax.inset_axes([0.75, 0.82, 0.2, 0.15])

# Desactivar las líneas de fondo del gráfico secundario
ax2.xaxis.grid(False)
ax2.yaxis.grid(False)

# Segundo gráfico - línea para los últimos 3 meses
lineplot = sns.lineplot(x=ingresos_mensuales.index.astype(str), y=ingresos_mensuales, color='blue', marker='o', ax=ax2)
ax2.set_title('Últimos 3 Meses')
ax2.set_xlabel('Fecha (Mes)')
ax2.set_ylabel('Ingresos')

# Formatear el eje Y del segundo gráfico en millones
ax2.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))

# Agregar etiquetas para cada barra en el gráfico principal
for rect in barplot:
    height = rect.get_height()
    ax.annotate(f'{height/1e6:.0f}M',
                xy=(rect.get_x() + rect.get_width() / 2, height),
                xytext=(0, 3),  # 3 points vertical offset
                textcoords="offset points",
                ha='center', va='bottom')

plt.tight_layout()
plt.show()

cleaned_data['fecha_pedido'] = pd.to_datetime(cleaned_data['fecha_pedido'])

# Calcular ingresos netos por mes
descuentos = cleaned_data.groupby(cleaned_data['fecha_pedido'].dt.to_period('M'))['descuento'].sum()

print(descuentos)

# Filtrar los datos para los últimos 3 meses excepto noviembre
ultimos_3_meses = cleaned_data[(cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=3)) & (cleaned_data['fecha_pedido'].dt.month != 11)]


# Agrupar por fecha y calcular los ingresos netos mensuales para los últimos 3 meses excepto noviembre
descuentos_mensuales = ultimos_3_meses.groupby(ultimos_3_meses['fecha_pedido'].dt.to_period('M'))['descuento'].sum()

# Configurar el estilo del fondo sin líneas
sns.set_style("whitegrid")

# Crear el gráfico de barras principal
fig, ax = plt.subplots(figsize=(14, 12))
barplot = ax.bar(descuentos.index.astype(str), -descuentos.values, color='skyblue')
ax.set_title('Total Descuentos Histórico')
ax.set_xlabel('Fecha')
ax.set_ylabel('Total descuentos (en millones)')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))
ax.tick_params(axis='x', rotation=45)

# Desactivar las líneas de fondo del gráfico principal
ax.xaxis.grid(False)
ax.yaxis.grid(False)

# Crear un eje secundario para el gráfico más pequeño (últimos 3 meses) dentro del gráfico principal
ax2 = ax.inset_axes([0.75, 0.82, 0.2, 0.15])

# Desactivar las líneas de fondo del gráfico secundario
ax2.xaxis.grid(False)
ax2.yaxis.grid(False)

# Segundo gráfico - línea para los últimos 3 meses
lineplot = sns.lineplot(x=descuentos_mensuales.index.astype(str), y=-descuentos_mensuales, color='blue', marker='o', ax=ax2)
ax2.set_title('Últimos 3 Meses')
ax2.set_xlabel('Fecha (Mes)')
ax2.set_ylabel('Descuentos')



# Formatear el eje Y del segundo gráfico en millones
ax2.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))

# Agregar etiquetas para cada barra en el gráfico principal
for rect in barplot:
    height = rect.get_height()
    ax.annotate(f'{height/1e6:.0f}M',
                xy=(rect.get_x() + rect.get_width() / 2, height),
                xytext=(0, 3),  # 3 points vertical offset
                textcoords="offset points",
                ha='center', va='bottom')

plt.tight_layout()
plt.show()

# Supongamos que la información relevante está en las columnas de productos
productos_cols = ['producto_a', 'producto_b', 'producto_c', 'producto_d', 'producto_e',
                   'producto_f', 'producto_g', 'producto_h', 'producto_i', 'producto_j', 'producto_k']

# Sumar las unidades vendidas por producto
total_unidades_por_producto = cleaned_data[productos_cols].sum()

# Crear un gráfico de barras con etiquetas
plt.figure(figsize=(12, 8))
barplot = sns.barplot(x=total_unidades_por_producto.index, y=total_unidades_por_producto.values, palette='viridis')

# Agregar etiquetas en cada barra
for rect in barplot.patches:
    height = rect.get_height()
    plt.text(rect.get_x() + rect.get_width() / 2, height, f'{height}',
             ha='center', va='bottom')

plt.title('Total de Unidades Vendidas por Producto')
plt.xlabel('Productos')
plt.ylabel('Total de Unidades Vendidas')
plt.xticks(rotation=45, ha='right')
plt.show()

"""#2. ESTADO DE CLIENTES

"""

plt.figure(figsize=(8, 6))
plot = sns.countplot(x='canal_compra', data=ultimos_3_meses, hue='tipo_canal', palette='viridis', order=cleaned_data['canal_compra'].sort_values().unique())

# Añadir etiquetas a cada barra
for p in plot.patches:
    plot.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
                  ha='center', va='center', fontsize=10, color='black', xytext=(0, 5),
                  textcoords='offset points')

plt.title('Distribución de Transacciones por Canal de Compra y Tipo de Canal últimos 3 meses')
plt.xlabel('Canal de Compra')
plt.ylabel('Cantidad de Transacciones')
plt.xticks(rotation=45)
plt.legend(title='Tipo de Canal')
plt.show()

plt.figure(figsize=(8, 6))
plot = sns.countplot(x='canal_compra', data=cleaned_data, hue='tipo_canal', palette='viridis', order=cleaned_data['canal_compra'].sort_values().unique())

# Añadir etiquetas a cada barra
for p in plot.patches:
    plot.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
                  ha='center', va='center', fontsize=10, color='black', xytext=(0, 5),
                  textcoords='offset points')

plt.title('Distribución de Transacciones por Canal de Compra y Tipo de Canal Histórico')
plt.xlabel('Canal de Compra')
plt.ylabel('Cantidad de Transacciones')
plt.xticks(rotation=45)
plt.legend(title='Tipo de Canal')
plt.show()

"""## 2.1 RFM

"""

# frecuencia de compra por cada cliente
frecuencia_compra = cleaned_data.groupby('cliente')['fecha_pedido'].count().reset_index()
frecuencia_compra.columns = ['cliente', 'frecuencia_compra']

# recencia en días por cada cliente
ultima_fecha = cleaned_data['fecha_pedido'].max()
recencia = cleaned_data.groupby('cliente')['fecha_pedido'].max().reset_index()
recencia['recencia'] = (ultima_fecha - recencia['fecha_pedido']).dt.days
recencia = recencia[['cliente', 'recencia']]

# monetary por cliente
monetary = cleaned_data.groupby('cliente')['ingresos_netos'].sum().reset_index()
monetary.columns = ['cliente', 'monetary']

# Combinar los DataFrames en uno solo
analisis_clientes = pd.merge(frecuencia_compra, recencia, on='cliente')
analisis_clientes = pd.merge(analisis_clientes, monetary, on='cliente')

analisis_clientes.to_csv('analisis_clientes.csv', index=False)

analisis_clientes

# Calcular la frecuencia de compra por cada cliente
frecuencia_compra = cleaned_data.groupby('cliente')['fecha_pedido'].count().reset_index()
frecuencia_compra.columns = ['cliente', 'frecuencia_compra']

# Encontrar el cliente con la mayor frecuencia
cliente_max_frecuencia = frecuencia_compra.loc[frecuencia_compra['frecuencia_compra'].idxmax()]


print("Cliente con mayor frecuencia:")
print(cliente_max_frecuencia)

sns.set_style("whitegrid")

# Crear un gráfico de dispersión para recencia y frecuencia
plt.figure(figsize=(12, 8))

# Convertir la columna 'monetary' a millones y agregarla al DataFrame
analisis_clientes['monetary_millions'] = analisis_clientes['monetary'] / 1e6

sns.scatterplot(data=analisis_clientes, x='recencia', y='frecuencia_compra', hue='monetary_millions', size='monetary_millions', sizes=(20, 200), palette='viridis')

# Formatear los ejes para mostrar la monetary en millones
plt.title('Análisis RFM por Cliente')
plt.xlabel('Recencia (días)')
plt.ylabel('Frecuencia de Compra')
plt.legend(title='Monetary (Millones)')

# Formatear el eje de la monetary en millones
plt.gca().xaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}'.format(x)))
plt.gca().yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}'.format(x)))

plt.show()

# Seleccionar solo las columnas correspondientes a los productos
columnas_productos = ['producto_a', 'producto_b', 'producto_c', 'producto_d', 'producto_e',
                      'producto_f', 'producto_g', 'producto_h', 'producto_i', 'producto_j',
                      'producto_k']

# Crear una nueva columna 'Total_Productos' que suma las unidades vendidas de todos los productos
cleaned_data['Total_Productos'] = cleaned_data[columnas_productos].sum(axis=1)

# Crear un nuevo DataFrame que muestra el número total de productos comprados por cada cliente
productos_por_cliente = cleaned_data.groupby('cliente')['Total_Productos'].sum().reset_index()

productos_por_cliente

"""#3. Estado de campañas

"""

# Crear una columna 'realizo_compra' que indica si el cliente realizó una compra o no
cleaned_data['realizo_compra'] = cleaned_data['estado'] == 'ATENDIDO'

# Calcular la eficiencia del canal de campaña
eficiencia_camp = cleaned_data.groupby('campania')['realizo_compra'].mean().reset_index()


# Ordenar las campañas alfabéticamente
eficiencia_camp = eficiencia_camp.sort_values(by='campania')

# Crear un gráfico de barras para la eficiencia del canal de campaña
plt.figure(figsize=(8, 3.5))
sns.barplot(x='campania', y='realizo_compra', data=eficiencia_camp, palette='viridis')
plt.title('Eficiencia de Campaña Historico')
plt.xlabel('Campaña')
plt.ylabel('Tasa de Conversión')
plt.xticks(rotation=45)

for index, value in enumerate(eficiencia_camp['realizo_compra']):
    plt.text(index, value + 0.01, f'{value:.2%}', ha='center', va='bottom')

plt.show()
# Filtrar datos para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]

# Calcular la eficiencia del canal de campaña para los últimos 3 meses
eficiencia_camp_ultimos_3_meses = ultimos_3_meses.groupby('campania')['realizo_compra'].mean().reset_index()

# Ordenar las campañas alfabéticamente
eficiencia_camp_ultimos_3_meses = eficiencia_camp_ultimos_3_meses.sort_values(by='campania')

# Crear un gráfico de barras para la eficiencia del canal de campaña (últimos 3 meses)
plt.figure(figsize=(8, 3.5))
sns.barplot(x='campania', y='realizo_compra', data=eficiencia_camp_ultimos_3_meses, palette='viridis')

# Anotar los valores de tasa de conversión en cada barra
for index, value in enumerate(eficiencia_camp_ultimos_3_meses['realizo_compra']):
    plt.text(index, value + 0.01, f'{value:.2%}', ha='center', va='bottom')

plt.title('Eficiencia de Campaña (Últimos 3 Meses)')
plt.xlabel('Campaña')
plt.ylabel('Tasa de Conversión')
plt.xticks(rotation=45)
plt.show()

# Calcular el total de ventas por campaña para toda la data
ventas_por_campania_historico = cleaned_data.groupby('campania')['valor'].sum().reset_index()

# Ordenar las campañas alfabéticamente
ventas_por_campania_historico = ventas_por_campania_historico.sort_values(by='campania')

# Crear un gráfico de barras para las ventas por campaña (histórico)
fig, ax1 = plt.subplots(figsize=(14, 8))

sns.barplot(x='campania', y='valor', data=ventas_por_campania_historico, palette='viridis', ax=ax1)

# Anotar los valores de ventas en cada barra
for index, value in enumerate(ventas_por_campania_historico['valor']):
    ax1.text(index, value + 100000, f'${value/1e6:.2f}M', ha='center', va='bottom')

ax1.set_title('Ventas por Campaña sin descuento(Histórico)')
ax1.set_xlabel('Campaña')
ax1.set_ylabel('Ventas (en millones)')
ax1.tick_params(axis='x', rotation=45)

# Calcular el total de ventas por campaña para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]
ventas_por_campania_ultimos_3_meses = ultimos_3_meses.groupby('campania')['valor'].sum().reset_index()

# Ordenar las campañas alfabéticamente
ventas_por_campania_ultimos_3_meses = ventas_por_campania_ultimos_3_meses.sort_values(by='campania')

# Crear un gráfico de barras para las ventas por campaña (últimos 3 meses)
ax2 = ax1.inset_axes([0.4, 0.6, 0.45, 0.3])

sns.barplot(x='campania', y='valor', data=ventas_por_campania_ultimos_3_meses, palette='viridis', ax=ax2)

# Anotar los valores de ventas en cada barra del gráfico secundario
for index, value in enumerate(ventas_por_campania_ultimos_3_meses['valor']):
    ax2.text(index, value + 5000, f'${value/1e6:.2f}M', ha='center', va='bottom')

ax2.set_title('Ventas por Campaña (Últimos 3 Meses)')
ax2.set_xlabel('Campaña')
ax2.set_ylabel('Ventas (en millones)')

# Formatear el eje y en millones
ax1.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))
ax2.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))

plt.tight_layout()
plt.show()

# Calcular el total de ventas por campaña para toda la data
ventas_por_campania_historico = cleaned_data.groupby('campania')['ingresos_netos'].sum().reset_index()

# Ordenar las campañas alfabéticamente
ventas_por_campania_historico = ventas_por_campania_historico.sort_values(by='campania')

# Crear un gráfico de barras para las ventas por campaña (histórico)
fig, ax1 = plt.subplots(figsize=(14, 8))

sns.barplot(x='campania', y='ingresos_netos', data=ventas_por_campania_historico, palette='viridis', ax=ax1)

# Anotar los valores de ventas en cada barra
for index, value in enumerate(ventas_por_campania_historico['ingresos_netos']):
    ax1.text(index, value + 100000, f'${value/1e6:.2f}M', ha='center', va='bottom')

ax1.set_title('Ventas por Campaña con descuento aplicado (Histórico)')
ax1.set_xlabel('Campaña')
ax1.set_ylabel('Ventas (en millones)')
ax1.tick_params(axis='x', rotation=45)

# Calcular el total de ventas por campaña para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]
ventas_por_campania_ultimos_3_meses = ultimos_3_meses.groupby('campania')['ingresos_netos'].sum().reset_index()

# Ordenar las campañas alfabéticamente
ventas_por_campania_ultimos_3_meses = ventas_por_campania_ultimos_3_meses.sort_values(by='campania')

# Crear un gráfico de barras para las ventas por campaña (últimos 3 meses)
ax2 = ax1.inset_axes([0.4, 0.6, 0.45, 0.3])

sns.barplot(x='campania', y='ingresos_netos', data=ventas_por_campania_ultimos_3_meses, palette='viridis', ax=ax2)

# Anotar los valores de ventas en cada barra del gráfico secundario
for index, value in enumerate(ventas_por_campania_ultimos_3_meses['ingresos_netos']):
    ax2.text(index, value + 5000, f'${value/1e6:.2f}M', ha='center', va='bottom')

ax2.set_title('Ventas por Campaña (Últimos 3 Meses)')
ax2.set_xlabel('Campaña')
ax2.set_ylabel('Ventas (en millones)')

# Formatear el eje y en millones
ax1.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))
ax2.yaxis.set_major_formatter(FuncFormatter(lambda x, _: '{:.0f}M'.format(x / 1e6)))

plt.tight_layout()
plt.show()

# Filtrar datos para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]

# Crear un gráfico de cajas para visualizar la distribución de descuentos por campaña
plt.figure(figsize=(12, 8))
sns.boxplot(x='campania', y=-cleaned_data['descuento'], data=cleaned_data, palette='viridis')
plt.title('Distribución de Descuentos por Campaña')
plt.xlabel('Campaña')
plt.ylabel('Descuento (en miles de millones)')
plt.xticks(rotation=45)
plt.show()

# Calcular la efectividad promedio de descuentos por campaña
efectividad_descuentos = cleaned_data.groupby('campania')['descuento'].mean().reset_index()

# Ordenar las campañas alfabéticamente
efectividad_descuentos = efectividad_descuentos.sort_values(by='campania')

# Crear un gráfico de barras para la efectividad promedio de descuentos por campaña
plt.figure(figsize=(8, 5))
sns.barplot(x='campania', y=-efectividad_descuentos['descuento'], data=efectividad_descuentos, palette='viridis')
plt.title('Efectividad Promedio de Descuentos por Campaña')
plt.xlabel('Campaña')
plt.ylabel('Descuento Promedio')
plt.xticks(rotation=45)
plt.show()

#cleaned_data['fecha_pedido'] = pd.to_datetime(cleaned_data['fecha_pedido'])

# Calcular ingresos netos por mes
descuentos = cleaned_data.groupby(cleaned_data['campania'])['descuento'].sum()

descuentos

# Filtrar datos para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]

# Crear un gráfico de cajas para visualizar la distribución de descuentos por campaña (histórico)
plt.figure(figsize=(12, 8))
sns.boxplot(x='campania', y=-cleaned_data['descuento'], data=cleaned_data, palette='viridis')
plt.title('Distribución de Descuentos por Campaña (Histórico)')
plt.xlabel('Campaña')
plt.ylabel('Descuento (en miles de millones)')
plt.xticks(rotation=45)
plt.show()

# Crear un gráfico de cajas para visualizar la distribución de descuentos por campaña (últimos 3 meses)
plt.figure(figsize=(12, 8))
sns.boxplot(x='campania', y=-ultimos_3_meses['descuento'], data=ultimos_3_meses, palette='viridis')
plt.title('Distribución de Descuentos por Campaña (Últimos 3 Meses)')
plt.xlabel('Campaña')
plt.ylabel('Descuento (en miles de millones)')
plt.xticks(rotation=45)
plt.show()

# Calcular la efectividad promedio de descuentos por campaña (histórico)
efectividad_descuentos_historico = cleaned_data.groupby('campania')['descuento'].mean().reset_index()

# Ordenar las campañas alfabéticamente
efectividad_descuentos_historico = efectividad_descuentos_historico.sort_values(by='campania')

# Crear un gráfico de barras para la efectividad promedio de descuentos por campaña (histórico)
plt.figure(figsize=(8, 5))
sns.barplot(x='campania', y=-efectividad_descuentos_historico['descuento'], data=efectividad_descuentos_historico, palette='viridis')
plt.title('Efectividad Promedio de Descuentos por Campaña (Histórico)')
plt.xlabel('Campaña')
plt.ylabel('Descuento Promedio')
plt.xticks(rotation=45)
plt.show()

# Calcular la efectividad promedio de descuentos por campaña (últimos 3 meses)
efectividad_descuentos_ultimos_3_meses = ultimos_3_meses.groupby('campania')['descuento'].mean().reset_index()

# Ordenar las campañas alfabéticamente
efectividad_descuentos_ultimos_3_meses = efectividad_descuentos_ultimos_3_meses.sort_values(by='campania')

# Crear un gráfico de barras para la efectividad promedio de descuentos por campaña (últimos 3 meses)
plt.figure(figsize=(8, 5))
sns.barplot(x='campania', y=-efectividad_descuentos_ultimos_3_meses['descuento'], data=efectividad_descuentos_ultimos_3_meses, palette='viridis')
plt.title('Efectividad Promedio de Descuentos por Campaña (Últimos 3 Meses)')
plt.xlabel('Campaña')
plt.ylabel('Descuento Promedio')
plt.xticks(rotation=45)
plt.show()

# Filtrar datos para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]

# Crear un gráfico de barras para visualizar la retención por estado de campaña
plt.figure(figsize=(12, 8))
sns.countplot(x='campania', hue='estado', data=ultimos_3_meses, palette='viridis')
plt.title('Retención por Estado de Campaña (Últimos 3 Meses)')
plt.xlabel('Campaña')
plt.ylabel('Cantidad de Transacciones')
plt.xticks(rotation=45)
plt.legend(title='Estado')
plt.show()

# Filtrar datos para los últimos 3 meses
ultimos_3_meses = cleaned_data[cleaned_data['fecha_pedido'] >= cleaned_data['fecha_pedido'].max() - pd.DateOffset(months=2)]

# Crear un gráfico de barras para visualizar la retención por estado de campaña (últimos 3 meses)
plt.figure(figsize=(12, 8))
sns.countplot(x='campania', hue='estado', data=ultimos_3_meses, palette='viridis')
plt.title(' Estado de Campaña (Últimos 3 Meses)')
plt.xlabel('Campaña')
plt.ylabel('Cantidad de Transacciones')
plt.xticks(rotation=45)
plt.legend(title='Estado')
plt.show()

# Calcular la retención por estado de campaña para datos históricos
retencion_historica = cleaned_data.groupby(['campania', 'estado'])['pedido'].count().reset_index()

# Crear un gráfico de barras apiladas para la retención por estado de campaña (histórico)
plt.figure(figsize=(12, 8))
sns.barplot(x='campania', y='pedido', hue='estado', data=retencion_historica, palette='viridis')
plt.title(' Estado de Campaña (Histórico)')
plt.xlabel('Campaña')
plt.ylabel('Cantidad de Transacciones')
plt.xticks(rotation=45)
plt.legend(title='Estado')
plt.show()

"""#ANALISIS EXPLORATORIO

"""

sns.set(style="whitegrid")
plt.figure(figsize=(10,5))
ax = sns.barplot(x="tipo_canal", y="total", data=cleaned_data.groupby("tipo_canal").sum().reset_index())
plt.title('Ventas por tipo de canal')
plt.show()

plt.figure(figsize=(10, 6))
sns.histplot(data=cleaned_data, x='descuento', bins=20, kde=True)
plt.title('Histograma de Descuentos')
plt.show()

cleaned_data['descuento'] = cleaned_data['descuento'] * -1  # Multiplicar por -1 para invertir el eje y

sns.scatterplot(data=cleaned_data, x='total', y='descuento')
plt.title('Relación entre Ventas y Descuentos')
plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(x='total', data=cleaned_data)
plt.title('Boxplot de Ventas Totales')
plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(x='descuento', data=cleaned_data)
plt.title('Boxplot de Montos de Descuento')
plt.show()

"""#MODELO DE SEGMENTACION DE CLIENTES

Se utilizará la segmentación de clustering con RFM
"""

df_rfm = pd.read_csv('analisis_clientes.csv', sep = ',')
df_rfm

df_rfm.describe()

# Establecer la columna "cliente" como índice
df_rfm = df_rfm.set_index('cliente')

df_rfm

for i in df_rfm.columns:
  print(str(i)+ ': ')
  ax = sns.boxplot(x=df_rfm[str(i)])
  plt.show()

df_rfm.monetary.plot.hist(bins=5)
plt.show()

df_rfm.recencia.plot.hist(bins=10)
plt.show()

df_rfm.frecuencia_compra.plot.hist(bins=5)
plt.show()

df_rfm.plot("recencia", "monetary", kind="scatter")
plt.show()

df_rfm.plot("recencia", "frecuencia_compra", kind="scatter")
plt.show()

"""*Se hará una estandarización para que todas las variables tengan la misma escala, lo que es importante para algoritmos de clustering que utilizan medidas de distancia, como K-Mean*"""

df_log= np.log1p(df_rfm)

scaler = StandardScaler()
scaler.fit(df_log)
df_norm = scaler.transform(df_log)

df_norm = pd.DataFrame(df_norm, columns=["frecuencia_compra", "recencia", "monetary"], index= df_rfm.index)
df_norm.head()

df_norm.recencia.plot(kind='hist')
plt.show()

df_norm.monetary.plot(kind='hist')
plt.show()

df_norm.plot.scatter("recencia", "frecuencia_compra")
plt.show()

df_norm.plot("recencia", "monetary", kind="scatter")
plt.show()

"""*Se utilizará el metodo del codo para  determinar el número óptimo de clusters.*"""

from sklearn.cluster import KMeans

df_norm.dropna(inplace=True)

varianza_explicada = []

# Probar diferentes valores de clusters
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, random_state=1, n_init="auto")
    kmeans.fit(df_norm)
    varianza_explicada.append(kmeans.inertia_)

# Graficar la varianza explicada en función del número de clusters
plt.plot(range(1, 11), varianza_explicada, marker='o')
plt.title('Método del Codo')
plt.xlabel('Número de Clusters')
plt.ylabel('Varianza Explicada')
plt.show()

"""*Segun los resultados del método del codo, se seleccionaran 4 clusters*"""

kmeans = KMeans(n_clusters=4, random_state=1, n_init="auto")

df_norm = df_norm.dropna()
kmeans.fit(df_norm)

np.unique(kmeans.labels_, return_counts=True)

print(dict(pd.Series(kmeans.labels_).value_counts()))

df_norm['cluster']=kmeans.labels_

df_norm['cluster']=df_norm['cluster'].astype("category")

df_norm.plot(x='recencia', y='monetary', c='cluster', kind='scatter')
plt.show()

df_norm.plot(x='frecuencia_compra', y='monetary', c='cluster', kind='scatter')
plt.show()

df_rfm.drop(df_rfm.tail(1).index, inplace=True)

# Verifica la longitud de las etiquetas generadas por KMeans
print(len(kmeans_labels))


# Verifica la longitud del DataFrame df_rfm
print(len(df_rfm))

kmeans_labels = kmeans.labels_
# Asignar kmeans_labels a la columna "cluster"
df_rfm["cluster"] = kmeans_labels

df_rfm["cluster"] = df_rfm["cluster"].astype("category")
#df_rfm["cluster_size"] = 1  # Agregar una columna para contar el tamaño del clúster

# Agrupar por clúster y calcular estadísticas
cluster_stats = df_rfm.groupby('cluster').agg(
    recencia=('recencia', 'mean'),
    frecuencia=('frecuencia_compra', 'mean'),
    monetary=('monetary', 'mean'),
    cluster_size=('monetary', 'count')
).round(1).sort_values(by='recencia')

# Establecer el clúster como índice
#cluster_stats.set_index("cluster", inplace=True)

# Visualizar el DataFrame resultante
print(cluster_stats)

cluster_stats

sns.barplot(data=df_rfm, x='cluster' , y='monetary')
plt.show()

sns.barplot(data=df_rfm, x='cluster' , y='recencia')
plt.show()

sns.barplot(data=df_rfm, x='cluster' , y='frecuencia_compra')
plt.show()

"""##VALIDACIÓN MODELO"""

from sklearn.model_selection import KFold
from sklearn.metrics import silhouette_score


df_modelo = df_rfm[['recencia', 'frecuencia_compra', 'monetary']]

# Número de clusters
n_clusters = 4

# Inicializar KFold para la validación cruzada
kf = KFold(n_splits=5, random_state=1, shuffle=True)

silhouette_scores = []

# Iterar sobre las particiones de entrenamiento y prueba
for train_index, test_index in kf.split(df_modelo):
    # Dividir el conjunto de datos
    X_train, X_test = df_modelo.iloc[train_index], df_modelo.iloc[test_index]

    # Inicializar y ajustar el modelo k-means
    kmeans = KMeans(n_clusters=n_clusters, random_state=1, n_init="auto")
    kmeans.fit(X_train)

    # Calcular el coeficiente de silueta para evaluar la calidad del clustering
    silhouette = silhouette_score(X_test, kmeans.predict(X_test))
    silhouette_scores.append(silhouette)

# Calcular el promedio de los coeficientes de silueta
average_silhouette = np.mean(silhouette_scores)

print(f"Coeficiente de Silueta Promedio: {average_silhouette}")

"""*Coeficiente de Silueta Promedio:*
- Interpretación: En términos generales, un coeficiente de silueta en el rango de 0.5 a 1 se considera que los clusters tienen una buena separación.

# COMENTARIOS DEL MODELO Y RESULTADOS

##Justificación de la Elección del Método:

El método de clustering con RFM (Recencia, Frecuencia, Monetary) es una elección sólida para la segmentación de clientes debido a sus ventajas en la identificación de patrones de comportamiento de compra. RFM es una técnica probada que utiliza tres dimensiones clave:

Estas variables proporcionan una comprensión holística del comportamiento del cliente y permiten la formación de clusters basados en similitudes.

##Selección de Variables Relevantes:

Las variables seleccionadas para la segmentación (Recencia, Frecuencia, Monetary) son altamente relevantes y predictivas en el contexto de la segmentación de clientes:

Recencia:  Clientes más recientes pueden tener comportamientos distintos a aquellos que no han comprado recientemente.

Frecuencia:  Clientes frecuentes pueden tener patrones de compra diferentes a los clientes esporádicos.

Monetary: Clientes que gastan más pueden tener necesidades y comportamientos diferentes a aquellos con menor gasto.


##Descripción de los Segmentos y recomendaciones:

Cluster 0 (Recencia: 98.6, Frecuencia: 2.4, Monetary: 3107409.4, Cluster Size: 27638): Este segmento muestra un tiempo reciente desde la última compra, baja frecuencia de compras, pero un valor monetario significativo. Pueden ser clientes que compran productos o servicios costosos con menos frecuencia.
Recomendaciones: Enfocar estrategias para aumentar la frecuencia de compra de este segmento, ofrecer incentivos para compras adicionales y mantenerlos informados sobre nuevos productos o promociones.

Cluster 3 (Recencia: 170.7, Frecuencia: 7.6, Monetary: 10926572.3, Cluster Size: 40220): Este segmento tiene clientes con una recencia moderada, alta frecuencia de compras y un valor monetario sustancial. Pueden representar clientes leales y valiosos para el negocio.
Recomendaciones: Ofrecer programas de fidelización, descuentos exclusivos para clientes frecuentes y mantener una comunicación constante para fortalecer la relación

Cluster 2 (Recencia: 326.7, Frecuencia: 2.9, Monetary: 4105878.0, Cluster Size: 73928): Este segmento tiene una recencia más alta, baja frecuencia y un valor monetario considerable. Pueden ser clientes que realizan compras grandes pero menos frecuentes.
Recomendaciones: Enfocarse en estrategias que fomenten compras más frecuentes, como recordatorios de productos o servicios relevantes y programas de recompensas.

Cluster 1 (Recencia: 377.2, Frecuencia: 1.6, Monetary: 1913720.9, Cluster Size: 95162): Este segmento muestra una recencia más alta, baja frecuencia y un valor monetario más bajo. Pueden ser clientes que compran ocasionalmente.
Recomendaciones: Implementar estrategias para reactivar a estos clientes, como ofertas personalizadas, promociones exclusivas y encuestas de satisfacción para comprender sus necesidades.
"""



